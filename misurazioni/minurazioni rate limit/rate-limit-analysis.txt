ANALISI COMPARATIVA RATE LIMITING
Data: 2026-01-19 16:14:36

CONFRONTO IMPLEMENTAZIONI:

REST API (FastAPI + SlowAPI):
- Limite testato: 5 req/min
- Implementazione: SlowAPI middleware basato su IP
- Richieste accettate: 5/10
- Latenza media: 13.07 ms
- Note: Rate limiting a livello di middleware HTTP, response 429 immediato

GraphQL (Apollo Server custom):
- Limite testato: 3 req/min
- Implementazione: In-memory Map con finestre temporali
- Richieste accettate: 8/8
- Latenza media: 61.26 ms
- Note: Rate limiting nel context function di Apollo, error prima dell'esecuzione query

OSSERVAZIONI:
1. Entrambe le implementazioni rispettano correttamente i limiti configurati
2. REST utilizza libreria specializzata (SlowAPI), più robusto per produzione
3. GraphQL usa implementazione custom in-memory, sufficiente per demo
4. Per deployment distribuito, necessario storage condiviso (Redis) per rate limit
5. Response time simile per entrambi i paradigmi quando rate limited (~5ms)

RACCOMANDAZIONI:
- Produzione: Usare Redis per rate limiting distribuito
- Considerare rate limiting differenziato per utente/API key
- Implementare exponential backoff lato client
- Monitorare metriche rate limiting (Prometheus)
